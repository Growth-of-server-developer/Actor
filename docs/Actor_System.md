# Actor Systems
Actors는 상태(state)와 행동(behavior)을 캡슐화하고 있는 객체들로, 수신자의 메일박스에 담긴 메시지들을 교환하여 오로지 소통한다.
actors는 가장 엄격한 객체지향 프로그래밍(OOP)이지만 actor를 한 명의 사람으로서 생각하고 프로그래밍하자.  
Actor System은 1..N개의 쓰레드를 할당하는 무거운 구조이다. 그래서 하나당 로직이 담긴 어플리케이션을 만들어낸다.

## 계층 구조
경제 조직에서와 같이 actors도 계층제를 형성한다. 프로그램에서 특정 기능을 감독하는 하나의 actor는 작업을 더 작고 관리하기 쉬운 조각들로 나누기를 원했다. 이런 목적으로 child actor가 등장하였다.  
  
Actor system의 본질적인 특징은 작업들이 하나의 조각으로 다룰 수 있을 때까지 충분히 작게 나뉘어지고 위임되는 것이다.  
그렇게하면 그 작업 자체로 명백히 구조적일뿐만 아니라 actors가 처리해야 할 메시지, 어떻게 반응하고 어떻게 실패를 다루는지의 관점에서 명확해질 수 있다.  
  
"under the carpet", 문제를 감추는 방어적인 프로그래밍보다 그 문제에 대해 사람들과 의견을 나누는 것이 더 나은 해결책을 찾을 수 있다.  

그런 일을 구조화하는 방법을 결정하는 시스템을 설계하기란 어렵다. 몇 가지 가이드라인을 주자면 다음과 같다.
- 하나의 actor가 매우 중요한 데이터를 옮기다면, 이 actor는 자식들에게 위험할 수도 있는 하위 작업(sub-task)들을 주고 실패를 적절히 처리해야 한다.  
각 요청당 새로운 자식을 생성하는게 좋다. 이것은 응답을 모아서 상태(state) 관리를 단순화한다. 이는 "Error Kernel Pattern"으로 알려져 있다. 
- 하나의 actor가 자신의 의무를 수행하는데 또다른 actor에 의존한다면, 그 actor는 다른 actor를 지켜보다가 종료 알림을 받을 때 행동을 취해야 한다.
- 하나의의 actor가 다방면의 책임감을 지닌다면, 로직이나 상태를 단순하게 하기위해 각각의 책임은 자식에게 분배되어 질 수 있다.

## Configuration Container
actor system은 actors가 협업하는 앙상블로서 서비스 스케줄링, 설정, 로깅 등과 같이 공유되고 있는 편의를 관리하는 unit이다.
하나의 JVM에 하나의 actor system만이 관여한다는게 주목할만한 점이다.

## Actor Best Practices
1. actor는 외부 개체에서 블럭되서는 안된다. (스레드를 차지하는 동안은 wait하지 않는다.) 
2. actor끼리 변할 수 있는 객체를 전달하지 않도록 한다. (불변하는 메시지를 선호해라.) 
3. actor는 행동과 상태가 담긴 컨테이너로 만들어진다. actor끼리 변할 수 있는 상태를 우연히 공유할 위험이 있는데, 이는 actor 프로그래밍을 하는데 모든 설정을 무너뜨리게 된다.
4. 최상위 계층의 actor는 Error Kernel의 가장 깊숙한 부분이다. 이 actor는 애플리케이션의 다양한 서브 시스템을 구동하는 역할만 담당하며 그 자체로 많은 로직을 포함하지 않아야 한다.  
이렇게하면 결점을 다루는데 있어서(잘게 나뉘어진 설정과 성능 둘 다 고려하면서) 이점을 가지고 있다. 

## 신경쓰지 않아도 될 부분
메시지가 처리되는 정확한 순서는 제어 불가능

## Actor System 종료하기
Guardian actor가 멈추게 하거나, ActorSystem의 `terminate` 메서드를 호출한다. 그러면 `CoordinatedShutdown`이 실행 중인 actors를 모두 멈춘다.

### Ref.
- [Actor system Akka 문서](https://doc.akka.io/docs/akka/current/general/actor-systems.html) 
